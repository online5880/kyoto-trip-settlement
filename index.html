<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#f4efe7" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png" />
  <title>교토 여행 초미니 정산</title>
  <style>
    :root {
      --bg: #f4efe7;
      --card: #fffdf8;
      --line: #d8ccbd;
      --text: #2f2a25;
      --muted: #7a6d61;
      --brand: #c16f45;
      --brand-soft: #f5e4d8;
      --danger: #b6413c;
      --ok: #6d825c;
      --tab-bg: #efe7dc;
      --tab-active: #2f2a25;
      --tab-active-text: #fffdf8;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body,
    #root {
      margin: 0;
      padding: 0;
      width: 100%;
      min-height: 100%;
      background: radial-gradient(circle at 20% 0%, #fbf5ec 0%, var(--bg) 45%, #ece1d3 100%);
      color: var(--text);
      font-family: "Pretendard", "Noto Sans KR", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .app {
      max-width: 560px;
      margin: 0 auto;
      min-height: 100dvh;
      padding: 14px 14px calc(90px + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
    }

    .header {
      margin-bottom: 12px;
    }

    .title {
      font-size: 22px;
      font-weight: 900;
      letter-spacing: -0.2px;
    }

    .subtitle {
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .stack {
      display: grid;
      gap: 10px;
      width: 100%;
    }

    .tab-content {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-bottom: 6px;
    }

    .card {
      background: color-mix(in srgb, var(--card) 96%, white 4%);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 6px 24px rgba(47, 42, 37, 0.06);
    }

    .settlement-card.done {
      background: #e6e2dc;
      color: #7a736d;
      border-color: #c5b8a7;
    }

    .settlement-card.done .settlement-line,
    .settlement-card.done .settlement-amount {
      text-decoration: line-through;
    }

    .settlement-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .label {
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .settled-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .settlement-line {
      text-align: center;
      font-size: 15px;
      font-weight: 700;
      line-height: 1.5;
    }

    .settlement-amount {
      display: inline-block;
      margin-top: 6px;
      width: 100%;
      text-align: center;
      font-size: 30px;
      font-weight: 900;
      color: var(--brand);
      letter-spacing: 0.2px;
      cursor: pointer;
      user-select: none;
    }

    .settlement-help {
      margin-top: 6px;
      text-align: center;
      font-size: 11px;
      color: var(--muted);
    }

    .summary-amount {
      font-size: 20px;
      font-weight: 900;
      margin-top: 6px;
    }

    .summary-grid {
      margin-top: 6px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .summary-col {
      padding: 8px 0;
    }

    .summary-col + .summary-col {
      border-left: 1px solid var(--line);
      padding-left: 10px;
    }

    .form {
      display: grid;
      gap: 8px;
    }

    .field {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--text);
      padding: 11px 12px;
      font-size: 16px;
    }

    .inline {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 8px;
    }

    .payer-toggle {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(96px, 1fr));
      gap: 6px;
      background: var(--tab-bg);
      border-radius: 12px;
      padding: 4px;
      border: 1px solid var(--line);
    }

    .payer-toggle button {
      border: 0;
      border-radius: 9px;
      padding: 10px;
      font-size: 14px;
      font-weight: 800;
      background: transparent;
      color: var(--muted);
    }

    .payer-toggle button.active {
      background: var(--tab-active);
      color: var(--tab-active-text);
    }

    .btn {
      width: 100%;
      border: 0;
      border-radius: 12px;
      padding: 11px 12px;
      font-size: 15px;
      font-weight: 800;
      background: var(--brand);
      color: #fff;
    }

    .btn.alt {
      background: #fff;
      color: var(--text);
      border: 1px solid var(--line);
    }

    .btn.danger {
      background: var(--danger);
    }

    .list {
      display: grid;
      gap: 8px;
    }

    .note-form {
      display: grid;
      gap: 8px;
    }

    .note-input {
      min-height: 84px;
      resize: vertical;
    }

    .note-list {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }

    .note-item {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .note-text {
      font-size: 14px;
      line-height: 1.5;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .note-text a {
      color: var(--brand);
      font-weight: 700;
      text-decoration: underline;
    }

    .note-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .note-actions {
      display: inline-flex;
      justify-content: flex-end;
      gap: 6px;
    }

    .row-item {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      display: grid;
      gap: 4px;
    }

    .row-top {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
    }

    .row-right {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    .row-time {
      font-size: 12px;
      color: var(--muted);
      min-width: 88px;
    }

    .row-title {
      font-size: 14px;
      font-weight: 800;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .row-meta {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
    }

    .settle-check {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .settle-check input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--brand);
      cursor: pointer;
    }

    .row-item.settled {
      opacity: 0.65;
      background: #f4f1ec;
    }

    .row-item.settled .row-title,
    .row-item.settled .row-meta span:first-child {
      text-decoration: line-through;
    }

    .chip {
      display: inline-block;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--tab-bg);
      padding: 2px 8px;
      font-size: 11px;
      color: var(--muted);
      margin-right: 6px;
    }

    .empty {
      text-align: center;
      font-size: 13px;
      color: var(--muted);
      padding: 16px 0;
    }

    .participant-list {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }

    .participant-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .participant-actions {
      display: inline-flex;
      gap: 6px;
    }

    .icon-btn {
      border: 1px solid var(--line);
      background: #fff;
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      font-weight: 700;
      white-space: nowrap;
    }

    .icon-btn.danger {
      border-color: #e2b9b5;
      color: var(--danger);
    }

    .bottom-nav {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 0;
      width: min(560px, 100%);
      padding: 8px 12px calc(8px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(244, 239, 231, 0) 0%, rgba(244, 239, 231, 0.85) 18%, rgba(244, 239, 231, 1) 100%);
      z-index: 40;
    }

    .bottom-nav-inner {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      background: var(--tab-bg);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 5px;
      box-shadow: 0 12px 26px rgba(47, 42, 37, 0.08);
    }

    .tab-btn {
      border: 0;
      border-radius: 12px;
      background: transparent;
      color: var(--muted);
      padding: 10px 4px;
      font-size: 13px;
      font-weight: 800;
    }

    .tab-btn.active {
      background: var(--tab-active);
      color: var(--tab-active-text);
    }

    .settings-row {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }

    .history-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    .history-controls {
      display: grid;
      gap: 8px;
      margin-bottom: 8px;
    }

    .history-actions {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
    }

    .history-two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .sync-state {
      font-size: 12px;
      color: var(--muted);
    }

    .undo-toast {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(78px + env(safe-area-inset-bottom));
      width: min(520px, calc(100% - 24px));
      background: #2f2a25;
      color: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      z-index: 50;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .undo-toast button {
      border: 0;
      border-radius: 8px;
      background: #fff;
      color: #2f2a25;
      font-size: 12px;
      font-weight: 800;
      padding: 7px 10px;
    }

    @media (min-width: 640px) {
      .app {
        padding-top: 18px;
      }
      .title {
        font-size: 24px;
      }
    }

    @media (max-width: 420px) {
      .history-two-col {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="module">
    import React, { useEffect, useMemo, useRef, useState } from "https://esm.sh/react@18.3.1";
    import { createRoot } from "https://esm.sh/react-dom@18.3.1/client";

    const STORAGE_KEY = "kyoto-mini-settlement-state-v2";
    const PENDING_KEY = "kyoto-mini-settlement-pending";
    const FALLBACK_RATE = 9.0;
    const DEFAULT_STATE = {
      participants: ["마네", "시원", "공금"],
      expenses: [],
      notes: [],
      rate: FALLBACK_RATE,
      payerSticky: "마네",
      sid: null,
      rateUpdatedAt: null
    };

    const TAB_MAIN = "main";
    const TAB_HISTORY = "history";
    const TAB_NOTES = "notes";
    const TAB_SETTINGS = "settings";

    function safeParse(json, fallback) {
      try {
        const parsed = JSON.parse(json);
        return parsed ?? fallback;
      } catch {
        return fallback;
      }
    }

    function parseAmount(input) {
      const n = Number(String(input || "").replace(/[^0-9]/g, ""));
      return Number.isFinite(n) ? n : 0;
    }

    function formatWithComma(input) {
      const n = parseAmount(input);
      return n ? n.toLocaleString("ko-KR") : "";
    }

    function formatDateTime(ts) {
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return "-";
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    function formatShortDateTime(ts) {
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return "--/-- --:--";
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      return `${mm}/${dd} ${hh}:${mi}`;
    }

    function splitTextWithLinks(text) {
      const source = String(text || "");
      const regex = /(https?:\/\/[^\s]+)/g;
      const parts = [];
      let lastIndex = 0;
      let match;
      while ((match = regex.exec(source)) !== null) {
        const start = match.index;
        const end = regex.lastIndex;
        if (start > lastIndex) {
          parts.push({ type: "text", value: source.slice(lastIndex, start) });
        }
        parts.push({ type: "link", value: match[0] });
        lastIndex = end;
      }
      if (lastIndex < source.length) {
        parts.push({ type: "text", value: source.slice(lastIndex) });
      }
      return parts.length ? parts : [{ type: "text", value: source }];
    }

    function amountLabel(expense, rate) {
      const amount = Number(expense.amount || 0);
      if (expense.currency === "JPY") {
        const krw = Math.round(amount * Number(rate || 0));
        return `${amount.toLocaleString("ko-KR")} 엔 (${krw.toLocaleString("ko-KR")} 원)`;
      }
      return `${amount.toLocaleString("ko-KR")} 원`;
    }

    function isFundAccountName(name) {
      const s = String(name || "").trim().toLowerCase();
      return s === "공금" || s === "데이트통장" || s === "데이트 통장" || s === "fund";
    }

    function calcSettlement(participants, expenses, rate) {
      const allNames = participants.length ? participants : ["마네", "시원", "공금"];
      const splitNames = allNames.filter((name) => !isFundAccountName(name));
      const namesForSplit = splitNames.length ? splitNames : allNames;
      const balances = Object.fromEntries(allNames.map((n) => [n, 0]));
      const pendingPaidBy = Object.fromEntries(namesForSplit.map((n) => [n, 0]));
      let total = 0;
      let fund = 0;
      let pending = 0;

      for (const e of expenses) {
        const amount = Number(e.amount || 0);
        const krw = e.currency === "JPY" ? amount * Number(rate || 0) : amount;
        total += krw;
        if (isFundAccountName(e.payer)) fund += krw;
        if (e.settled) continue;
        if (isFundAccountName(e.payer)) continue;
        pending += krw;
        if (pendingPaidBy[e.payer] == null) pendingPaidBy[e.payer] = 0;
        pendingPaidBy[e.payer] += krw;

        const split = krw / namesForSplit.length;
        for (const name of namesForSplit) balances[name] -= split;
        if (balances[e.payer] == null) balances[e.payer] = 0;
        balances[e.payer] += krw;
      }

      const debtors = [];
      const creditors = [];
      for (const [name, value] of Object.entries(balances)) {
        if (value < -1) debtors.push([name, -value]);
        else if (value > 1) creditors.push([name, value]);
      }
      debtors.sort((a, b) => b[1] - a[1]);
      creditors.sort((a, b) => b[1] - a[1]);

      const transfers = [];
      let i = 0;
      let j = 0;
      while (i < debtors.length && j < creditors.length) {
        const [from, owe] = debtors[i];
        const [to, recv] = creditors[j];
        const amount = Math.round(Math.min(owe, recv));
        if (amount > 0) transfers.push({ from, to, amount });
        debtors[i][1] -= amount;
        creditors[j][1] -= amount;
        if (debtors[i][1] <= 1) i += 1;
        if (creditors[j][1] <= 1) j += 1;
      }

      let directionalSplit = null;
      if (namesForSplit.length === 2) {
        const [nameA, nameB] = namesForSplit;
        const paidByA = Number(pendingPaidBy[nameA] || 0);
        const paidByB = Number(pendingPaidBy[nameB] || 0);
        const aToB = Math.round(paidByB / 2);
        const bToA = Math.round(paidByA / 2);
        const diff = bToA - aToB;
        directionalSplit = {
          nameA,
          nameB,
          aToB,
          bToA,
          netFrom: diff > 0 ? nameB : nameA,
          netTo: diff > 0 ? nameA : nameB,
          netAmount: Math.abs(diff)
        };
      }

      return {
        totalKrw: Math.round(total),
        fundKrw: Math.round(fund),
        pendingKrw: Math.round(pending),
        transfers,
        directionalSplit
      };
    }

    function normalizeState(raw) {
      const merged = {
        ...DEFAULT_STATE,
        ...raw
      };

      const participants = Array.isArray(merged.participants)
        ? merged.participants.map((v) => String(v || "").trim()).filter(Boolean)
        : DEFAULT_STATE.participants;

      const expenses = Array.isArray(merged.expenses)
        ? merged.expenses
            .map((e) => ({
              id: String(e.id || crypto.randomUUID()),
              title: String(e.title || "지출"),
              amount: Number(e.amount || 0),
              currency: e.currency === "JPY" ? "JPY" : "KRW",
              payer: String(e.payer || participants[0] || "마네"),
              createdAt: Number(e.createdAt || Date.now()),
              settled: Boolean(e.settled)
            }))
            .filter((e) => e.amount > 0)
        : [];

      const notes = Array.isArray(merged.notes)
        ? merged.notes
            .map((n) => ({
              id: String(n.id || crypto.randomUUID()),
              text: String(n.text || "").trim(),
              createdAt: Number(n.createdAt || Date.now()),
              updatedAt: Number(n.updatedAt || n.createdAt || Date.now())
            }))
            .filter((n) => n.text.length > 0)
        : [];

      const uniqueParticipants = Array.from(new Set(participants.length ? participants : DEFAULT_STATE.participants));
      if (!uniqueParticipants.some((p) => isFundAccountName(p))) uniqueParticipants.push("공금");
      const payerSticky = uniqueParticipants.includes(merged.payerSticky)
        ? merged.payerSticky
        : uniqueParticipants[0];

      return {
        participants: uniqueParticipants,
        expenses,
        notes,
        rate: Number(merged.rate || FALLBACK_RATE),
        payerSticky,
        sid: merged.sid ? String(merged.sid) : null,
        rateUpdatedAt: merged.rateUpdatedAt ? String(merged.rateUpdatedAt) : null
      };
    }

    function App() {
      const urlSid = new URL(window.location.href).searchParams.get("sid");
      const localInitial = normalizeState(safeParse(localStorage.getItem(STORAGE_KEY), DEFAULT_STATE));
      const [state, setState] = useState(() => normalizeState({ ...localInitial, sid: urlSid || localInitial.sid }));
      const [tab, setTab] = useState(TAB_MAIN);
      const [title, setTitle] = useState("");
      const [amountText, setAmountText] = useState("");
      const [currency, setCurrency] = useState("JPY");
      const [payer, setPayer] = useState(() => (localInitial.payerSticky || localInitial.participants[0] || "마네"));
      const [newParticipant, setNewParticipant] = useState("");
      const [syncLabel, setSyncLabel] = useState("동기화 미연결");
      const [busy, setBusy] = useState(false);
      const [lastDeleted, setLastDeleted] = useState(null);
      const [historySort, setHistorySort] = useState("newest");
      const [historySettledFilter, setHistorySettledFilter] = useState("all");
      const [historyPayerFilter, setHistoryPayerFilter] = useState("all");
      const [historyCurrencyFilter, setHistoryCurrencyFilter] = useState("all");
      const [historyQuery, setHistoryQuery] = useState("");
      const [historyControlsOpen, setHistoryControlsOpen] = useState(false);
      const [noteText, setNoteText] = useState("");
      const [editingNoteId, setEditingNoteId] = useState(null);
      const [editingNoteText, setEditingNoteText] = useState("");
      const pollRef = useRef(null);
      const pushTimerRef = useRef(null);
      const undoTimerRef = useRef(null);
      const applyingRemoteRef = useRef(false);
      const lastRemoteFpRef = useRef("");

      const settlement = useMemo(() => calcSettlement(state.participants, state.expenses, state.rate), [state.participants, state.expenses, state.rate]);

      const recentFive = useMemo(
        () => [...state.expenses].sort((a, b) => b.createdAt - a.createdAt).slice(0, 5),
        [state.expenses]
      );

      const fullHistory = useMemo(() => [...state.expenses], [state.expenses]);

      const filteredHistory = useMemo(() => {
        const query = historyQuery.trim().toLowerCase();
        const toKrw = (expense) => {
          const amount = Number(expense.amount || 0);
          return expense.currency === "JPY" ? amount * Number(state.rate || 0) : amount;
        };

        const list = fullHistory
          .filter((e) => {
            if (historySettledFilter === "settled") return !!e.settled;
            if (historySettledFilter === "unsettled") return !e.settled;
            return true;
          })
          .filter((e) => (historyPayerFilter === "all" ? true : e.payer === historyPayerFilter))
          .filter((e) => (historyCurrencyFilter === "all" ? true : e.currency === historyCurrencyFilter))
          .filter((e) => {
            if (!query) return true;
            return String(e.title || "").toLowerCase().includes(query);
          });

        list.sort((a, b) => {
          if (historySort === "oldest") return a.createdAt - b.createdAt;
          if (historySort === "amountDesc") return toKrw(b) - toKrw(a);
          if (historySort === "amountAsc") return toKrw(a) - toKrw(b);
          return b.createdAt - a.createdAt;
        });

        return list;
      }, [fullHistory, historySort, historySettledFilter, historyPayerFilter, historyCurrencyFilter, historyQuery, state.rate]);

      const activeHistoryFilterCount = [
        historySort !== "newest",
        historySettledFilter !== "all",
        historyPayerFilter !== "all",
        historyCurrencyFilter !== "all",
        historyQuery.trim() !== ""
      ].filter(Boolean).length;

      function resetHistoryFilters() {
        setHistorySort("newest");
        setHistorySettledFilter("all");
        setHistoryPayerFilter("all");
        setHistoryCurrencyFilter("all");
        setHistoryQuery("");
      }

      const hasPendingSettlement = settlement.pendingKrw > 0;
      const directionalSplit = settlement.directionalSplit;

      useEffect(() => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }, [state]);

      useEffect(() => {
        if (!state.participants.includes(payer)) {
          setPayer(state.participants[0] || "마네");
        }
      }, [state.participants, payer]);

      useEffect(() => {
        return () => {
          if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
        };
      }, []);

      useEffect(() => {
        if (!state.sid) {
          setSyncLabel("동기화 미연결");
          if (pollRef.current) {
            clearInterval(pollRef.current);
            pollRef.current = null;
          }
          return;
        }

        setSyncLabel(`실시간 동기화 ON (sid: ${state.sid})`);
        if (pollRef.current) clearInterval(pollRef.current);
        pollRef.current = setInterval(() => {
          pullRemote(state.sid);
        }, 3500);

        return () => {
          if (pollRef.current) {
            clearInterval(pollRef.current);
            pollRef.current = null;
          }
        };
      }, [state.sid]);

      async function fetchRate() {
        setBusy(true);
        try {
          const res = await fetch("https://open.er-api.com/v6/latest/JPY");
          const data = await res.json();
          const krw = Number(data?.rates?.KRW || 0);
          if (!krw) throw new Error("KRW rate missing");

          setState((prev) => ({
            ...prev,
            rate: krw,
            rateUpdatedAt: data?.time_last_update_utc || new Date().toISOString()
          }));
        } catch {
          alert("환율 조회에 실패했습니다. 네트워크를 확인해 주세요.");
        } finally {
          setBusy(false);
        }
      }

      function queuePush(nextState) {
        if (!nextState.sid || applyingRemoteRef.current) return;
        if (pushTimerRef.current) clearTimeout(pushTimerRef.current);
        pushTimerRef.current = setTimeout(() => {
          pushRemote(nextState.sid, nextState);
        }, 500);
      }

      async function createOrCopySyncLink() {
        setBusy(true);
        try {
          let sid = state.sid;
          if (!sid) {
            const res = await fetch("/api/share", {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify({ state })
            });
            if (!res.ok) throw new Error("create failed");
            const body = await res.json();
            sid = body.id;
            setState((prev) => ({ ...prev, sid }));
            const url = new URL(window.location.href);
            url.searchParams.set("sid", sid);
            window.history.replaceState(null, "", url.toString());
          }

          const share = `${window.location.origin}${window.location.pathname}?sid=${sid}`;
          await navigator.clipboard.writeText(share);
          setSyncLabel(`링크 복사됨 (sid: ${sid})`);
        } catch {
          alert("동기화 링크 생성/복사에 실패했습니다.");
        } finally {
          setBusy(false);
        }
      }

      async function pushRemote(sid, nextState) {
        try {
          await fetch(`/api/share/${encodeURIComponent(sid)}`, {
            method: "PUT",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ state: nextState })
          });
          localStorage.removeItem(PENDING_KEY);
        } catch {
          localStorage.setItem(PENDING_KEY, JSON.stringify(nextState));
        }
      }

      async function pullRemote(sid) {
        if (!sid || applyingRemoteRef.current) return;
        try {
          const res = await fetch(`/api/share/${encodeURIComponent(sid)}`);
          if (!res.ok) return;
          const body = await res.json();
          const remoteState = normalizeState(body?.state || DEFAULT_STATE);
          const fp = JSON.stringify(remoteState);
          if (fp === lastRemoteFpRef.current) return;

          applyingRemoteRef.current = true;
          setState((prev) => {
            const merged = normalizeState({ ...remoteState, sid: prev.sid || sid });
            lastRemoteFpRef.current = JSON.stringify(merged);
            return merged;
          });
        } catch {
          // no-op
        } finally {
          applyingRemoteRef.current = false;
        }
      }

      useEffect(() => {
        if (!urlSid) return;
        pullRemote(urlSid);
      }, [urlSid]);

      useEffect(() => {
        const pending = safeParse(localStorage.getItem(PENDING_KEY), null);
        if (!pending || !state.sid || !navigator.onLine) return;
        pushRemote(state.sid, pending);
      }, [state.sid]);

      function updateState(updater) {
        setState((prev) => {
          const next = normalizeState(typeof updater === "function" ? updater(prev) : updater);
          queuePush(next);
          return next;
        });
      }

      function onSubmitExpense(e) {
        e.preventDefault();
        const parsed = parseAmount(amountText);
        if (!parsed) return;

        const safePayer = state.participants.includes(payer) ? payer : state.participants[0];
        if (!safePayer) return;

        updateState((prev) => ({
          ...prev,
          payerSticky: safePayer,
          expenses: [
            ...prev.expenses,
            {
              id: crypto.randomUUID(),
              title: title.trim() || "지출",
              amount: parsed,
              currency,
              payer: safePayer,
              createdAt: Date.now(),
              settled: false
            }
          ]
        }));

        setTitle("");
        setAmountText("");
      }

      function removeExpense(id) {
        const target = state.expenses.find((e) => e.id === id);
        if (!target) return;
        if (!confirm(`'${target.title}' 지출을 삭제할까요?`)) return;

        updateState((prev) => ({
          ...prev,
          expenses: prev.expenses.filter((e) => e.id !== id)
        }));

        setLastDeleted(target);
        if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
        undoTimerRef.current = setTimeout(() => {
          setLastDeleted(null);
        }, 5000);
      }

      function toggleExpenseSettled(id, checked) {
        updateState((prev) => ({
          ...prev,
          expenses: prev.expenses.map((e) => (e.id === id ? { ...e, settled: checked } : e))
        }));
      }

      function undoRemoveExpense() {
        if (!lastDeleted) return;
        const restoreItem = lastDeleted;
        if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
        setLastDeleted(null);
        updateState((prev) => ({
          ...prev,
          expenses: [...prev.expenses, restoreItem]
        }));
      }

      function addNote() {
        const text = noteText.trim();
        if (!text) return;
        const now = Date.now();
        updateState((prev) => ({
          ...prev,
          notes: [
            {
              id: crypto.randomUUID(),
              text,
              createdAt: now,
              updatedAt: now
            },
            ...prev.notes
          ]
        }));
        setNoteText("");
      }

      function startEditNote(note) {
        setEditingNoteId(note.id);
        setEditingNoteText(note.text);
      }

      function cancelEditNote() {
        setEditingNoteId(null);
        setEditingNoteText("");
      }

      function saveEditNote(noteId) {
        const nextText = editingNoteText.trim();
        if (!nextText) {
          alert("메모 내용을 입력해 주세요.");
          return;
        }
        updateState((prev) => ({
          ...prev,
          notes: prev.notes.map((n) => (n.id === noteId ? { ...n, text: nextText, updatedAt: Date.now() } : n))
        }));
        cancelEditNote();
      }

      function deleteNote(noteId) {
        const target = state.notes.find((n) => n.id === noteId);
        if (!target) return;
        if (!confirm("이 메모를 삭제할까요?")) return;
        updateState((prev) => ({
          ...prev,
          notes: prev.notes.filter((n) => n.id !== noteId)
        }));
        if (editingNoteId === noteId) cancelEditNote();
      }

      function addParticipant() {
        const name = newParticipant.trim();
        if (!name) return;
        if (state.participants.includes(name)) {
          alert("이미 있는 이름입니다.");
          return;
        }
        updateState((prev) => ({
          ...prev,
          participants: [...prev.participants, name]
        }));
        setNewParticipant("");
      }

      function renameParticipant(from, to) {
        const nextName = to.trim();
        if (!nextName || nextName === from) return;
        if (state.participants.includes(nextName)) {
          alert("이미 있는 이름입니다.");
          return;
        }

        updateState((prev) => ({
          ...prev,
          participants: prev.participants.map((p) => (p === from ? nextName : p)),
          expenses: prev.expenses.map((e) => ({
            ...e,
            payer: e.payer === from ? nextName : e.payer
          })),
          payerSticky: prev.payerSticky === from ? nextName : prev.payerSticky
        }));

        if (payer === from) setPayer(nextName);
      }

      function deleteParticipant(name) {
        const nonFundCount = state.participants.filter((p) => !isFundAccountName(p)).length;
        if (!isFundAccountName(name) && nonFundCount <= 2) {
          alert("실제 참여자(사람)는 최소 2명 유지해야 합니다.");
          return;
        }
        if (!confirm(`${name} 참여자를 삭제할까요?`)) return;

        updateState((prev) => {
          const remaining = prev.participants.filter((p) => p !== name);
          const fallback = remaining[0];
          return {
            ...prev,
            participants: remaining,
            expenses: prev.expenses.map((e) => (e.payer === name ? { ...e, payer: fallback } : e)),
            payerSticky: prev.payerSticky === name ? fallback : prev.payerSticky
          };
        });

        if (payer === name) {
          const fallback = state.participants.find((p) => p !== name) || "마네";
          setPayer(fallback);
        }
      }

      async function copyAmount(amount) {
        try {
          await navigator.clipboard.writeText(String(amount));
          alert(`${amount.toLocaleString("ko-KR")} 원 복사됨`);
        } catch {
          alert("복사에 실패했습니다.");
        }
      }

      function resetAll() {
        if (!confirm("전체 데이터를 초기화할까요?")) return;
        const base = normalizeState({ ...DEFAULT_STATE, sid: state.sid });
        setTitle("");
        setAmountText("");
        setCurrency("JPY");
        setPayer(base.payerSticky);
        updateState(base);
      }

      return (
        React.createElement("div", { className: "app" },
          React.createElement("header", { className: "header" },
            React.createElement("div", { className: "title" }, "교토 여행 정산"),
            React.createElement("div", { className: "subtitle" }, "빠른 입력 · 즉시 정산 · 모바일 전용")
          ),

          React.createElement("div", { className: "tab-content" },
          tab === TAB_MAIN && React.createElement("section", { className: "stack" },
            React.createElement("article", { className: "card settlement-card" },
              React.createElement("div", { className: "settlement-head" },
                React.createElement("span", { className: "label" }, "남은 정산")
              ),
              hasPendingSettlement
                ? React.createElement(React.Fragment, null,
                    directionalSplit && React.createElement(React.Fragment, null,
                      React.createElement("div", { className: "settlement-line" }, `${directionalSplit.nameA} → ${directionalSplit.nameB}: ${directionalSplit.aToB.toLocaleString("ko-KR")} 원`),
                      React.createElement("div", { className: "settlement-line" }, `${directionalSplit.nameB} → ${directionalSplit.nameA}: ${directionalSplit.bToA.toLocaleString("ko-KR")} 원`)
                    ),
                    React.createElement("div", {
                      className: "settlement-amount",
                      onClick: () => copyAmount(directionalSplit ? directionalSplit.netAmount : settlement.pendingKrw)
                    }, directionalSplit
                      ? directionalSplit.netAmount > 0
                        ? `${directionalSplit.netFrom} → ${directionalSplit.netTo} ${directionalSplit.netAmount.toLocaleString("ko-KR")} 원`
                        : "최종 송금 없음 (0원)"
                      : `${settlement.pendingKrw.toLocaleString("ko-KR")} 원`),
                    React.createElement("div", { className: "settlement-help" }, directionalSplit
                      ? "양방향 절반 금액 + 최종 상계 결과 · 금액 탭하면 복사됩니다"
                      : "남은 정산 총액 · 금액 탭하면 복사됩니다")
                  )
                : React.createElement("div", { className: "settlement-line" }, "모든 지출 정산 체크 완료")
            ),

            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "summary-grid" },
                React.createElement("div", { className: "summary-col" },
                  React.createElement("div", { className: "label" }, "총 지출"),
                  React.createElement("div", { className: "summary-amount" }, `${settlement.totalKrw.toLocaleString("ko-KR")} 원`)
                ),
                React.createElement("div", { className: "summary-col" },
                  React.createElement("div", { className: "label" }, "공금 지출"),
                  React.createElement("div", { className: "summary-amount" }, `${settlement.fundKrw.toLocaleString("ko-KR")} 원`)
                )
              )
            ),

            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "label" }, "지출 입력"),
              React.createElement("form", { className: "form", onSubmit: onSubmitExpense },
                React.createElement("input", {
                  className: "field",
                  placeholder: "항목명",
                  value: title,
                  onChange: (e) => setTitle(e.target.value)
                }),
                React.createElement("div", { className: "inline" },
                  React.createElement("input", {
                    className: "field",
                    inputMode: "numeric",
                    placeholder: "금액",
                    value: amountText,
                    onChange: (e) => setAmountText(formatWithComma(e.target.value))
                  }),
                  React.createElement("select", {
                    className: "field",
                    value: currency,
                    onChange: (e) => setCurrency(e.target.value)
                  },
                    React.createElement("option", { value: "JPY" }, "엔"),
                    React.createElement("option", { value: "KRW" }, "원")
                  )
                ),
                React.createElement("div", { className: "payer-toggle" },
                  state.participants.map((name) =>
                    React.createElement("button", {
                      key: name,
                      type: "button",
                      className: payer === name ? "active" : "",
                      onClick: () => {
                        setPayer(name);
                        updateState((prev) => ({ ...prev, payerSticky: name }));
                      }
                    }, name)
                  )
                ),
                React.createElement("div", { className: "sync-state" }, "결제자에 공금을 선택하면 분담은 사람(마네/시원)에게만 적용됩니다."),
                React.createElement("button", { className: "btn", type: "submit" }, "지출 등록")
              )
            ),

            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "label", style: { marginBottom: "8px" } }, "최근 지출 5개"),
              recentFive.length === 0
                ? React.createElement("div", { className: "empty" }, "아직 기록이 없습니다")
                : React.createElement("div", { className: "list" },
                    recentFive.map((e) =>
                      React.createElement("div", { key: e.id, className: `row-item ${e.settled ? "settled" : ""}` },
                        React.createElement("div", { className: "row-top" },
                          React.createElement("span", { className: "row-time" }, formatShortDateTime(e.createdAt)),
                          React.createElement("span", { className: "row-title" }, e.title),
                          React.createElement("div", { className: "row-right" },
                            React.createElement("label", { className: "settle-check" },
                              React.createElement("input", {
                                type: "checkbox",
                                checked: !!e.settled,
                                onChange: (ev) => toggleExpenseSettled(e.id, ev.target.checked)
                              }),
                              "정산"
                            ),
                            React.createElement("button", { className: "icon-btn danger", onClick: () => removeExpense(e.id) }, "삭제")
                          )
                        ),
                        React.createElement("div", { className: "row-meta" },
                          React.createElement("span", null, amountLabel(e, state.rate)),
                          React.createElement("span", { className: "chip" }, e.payer)
                        )
                      )
                    )
                  )
            )
          ),

          tab === TAB_HISTORY && React.createElement("section", { className: "stack" },
            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "history-head" },
                React.createElement("div", { className: "label" }, "전체 지출 히스토리"),
                React.createElement("button", {
                  className: "icon-btn",
                  type: "button",
                  onClick: () => setHistoryControlsOpen((prev) => !prev)
                }, historyControlsOpen
                  ? "필터 접기"
                  : activeHistoryFilterCount > 0
                    ? `☰ 필터/정렬 (${activeHistoryFilterCount})`
                    : "☰ 필터/정렬")
              ),
              historyControlsOpen && React.createElement("div", { className: "history-controls" },
                React.createElement("div", { className: "history-two-col" },
                  React.createElement("select", {
                    className: "field",
                    value: historySort,
                    onChange: (e) => setHistorySort(e.target.value)
                  },
                    React.createElement("option", { value: "newest" }, "정렬: 최신순"),
                    React.createElement("option", { value: "oldest" }, "정렬: 오래된순"),
                    React.createElement("option", { value: "amountDesc" }, "정렬: 금액 큰순"),
                    React.createElement("option", { value: "amountAsc" }, "정렬: 금액 작은순")
                  ),
                  React.createElement("select", {
                    className: "field",
                    value: historySettledFilter,
                    onChange: (e) => setHistorySettledFilter(e.target.value)
                  },
                    React.createElement("option", { value: "all" }, "정산: 전체"),
                    React.createElement("option", { value: "unsettled" }, "정산: 미완료"),
                    React.createElement("option", { value: "settled" }, "정산: 완료")
                  )
                ),
                React.createElement("div", { className: "history-two-col" },
                  React.createElement("select", {
                    className: "field",
                    value: historyPayerFilter,
                    onChange: (e) => setHistoryPayerFilter(e.target.value)
                  },
                    React.createElement("option", { value: "all" }, "결제자: 전체"),
                    state.participants.map((name) =>
                      React.createElement("option", { key: name, value: name }, `결제자: ${name}`)
                    )
                  ),
                  React.createElement("select", {
                    className: "field",
                    value: historyCurrencyFilter,
                    onChange: (e) => setHistoryCurrencyFilter(e.target.value)
                  },
                    React.createElement("option", { value: "all" }, "통화: 전체"),
                    React.createElement("option", { value: "JPY" }, "통화: 엔"),
                    React.createElement("option", { value: "KRW" }, "통화: 원")
                  )
                ),
                React.createElement("input", {
                  className: "field",
                  placeholder: "항목명 검색",
                  value: historyQuery,
                  onChange: (e) => setHistoryQuery(e.target.value)
                }),
                React.createElement("div", { className: "history-actions" },
                  React.createElement("button", {
                    className: "icon-btn",
                    type: "button",
                    onClick: resetHistoryFilters
                  }, "필터 초기화"),
                  React.createElement("button", {
                    className: "icon-btn",
                    type: "button",
                    onClick: () => setHistoryControlsOpen(false)
                  }, "닫기")
                )
              ),
              fullHistory.length === 0
                ? React.createElement("div", { className: "empty" }, "아직 기록이 없습니다")
                : filteredHistory.length === 0
                  ? React.createElement("div", { className: "empty" }, "조건에 맞는 기록이 없습니다")
                : React.createElement("div", { className: "list" },
                    filteredHistory.map((e) =>
                      React.createElement("div", { key: e.id, className: `row-item ${e.settled ? "settled" : ""}` },
                        React.createElement("div", { className: "row-top" },
                          React.createElement("span", { className: "row-time" }, formatDateTime(e.createdAt)),
                          React.createElement("span", { className: "row-title" }, e.title),
                          React.createElement("div", { className: "row-right" },
                            React.createElement("label", { className: "settle-check" },
                              React.createElement("input", {
                                type: "checkbox",
                                checked: !!e.settled,
                                onChange: (ev) => toggleExpenseSettled(e.id, ev.target.checked)
                              }),
                              "정산"
                            ),
                            React.createElement("button", { className: "icon-btn danger", onClick: () => removeExpense(e.id) }, "삭제")
                          )
                        ),
                        React.createElement("div", { className: "row-meta" },
                          React.createElement("span", null, amountLabel(e, state.rate)),
                          React.createElement("span", { className: "chip" }, e.payer)
                        )
                      )
                    )
                  )
            )
          ),

          tab === TAB_NOTES && React.createElement("section", { className: "stack" },
            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "label", style: { marginBottom: "8px" } }, "메모"),
              React.createElement("div", { className: "sync-state", style: { marginBottom: "8px" } }, "일반 텍스트/링크를 함께 저장할 수 있습니다."),
              React.createElement("div", { className: "note-form" },
                React.createElement("textarea", {
                  className: "field note-input",
                  placeholder: "예) https://guest-ui.west-qr.com/#/ 이 링크는 하루카 티켓 볼 수 있음",
                  value: noteText,
                  onChange: (e) => setNoteText(e.target.value)
                }),
                React.createElement("button", { className: "btn", type: "button", onClick: addNote }, "메모 추가")
              ),
              state.notes.length === 0
                ? React.createElement("div", { className: "empty" }, "아직 메모가 없습니다")
                : React.createElement("div", { className: "note-list" },
                    state.notes
                      .slice()
                      .sort((a, b) => b.createdAt - a.createdAt)
                      .map((note) => {
                        const editing = editingNoteId === note.id;
                        return React.createElement("div", { key: note.id, className: "note-item" },
                          editing
                            ? React.createElement("textarea", {
                                className: "field note-input",
                                value: editingNoteText,
                                onChange: (e) => setEditingNoteText(e.target.value)
                              })
                            : React.createElement("div", { className: "note-text" },
                                splitTextWithLinks(note.text).map((part, idx) =>
                                  part.type === "link"
                                    ? React.createElement("a", {
                                        key: `${note.id}-part-${idx}`,
                                        href: part.value,
                                        target: "_blank",
                                        rel: "noreferrer noopener"
                                      }, part.value)
                                    : React.createElement("span", { key: `${note.id}-part-${idx}` }, part.value)
                                )
                              ),
                          React.createElement("div", { className: "note-meta" },
                            `작성: ${formatDateTime(note.createdAt)} · 수정: ${formatDateTime(note.updatedAt)}`
                          ),
                          React.createElement("div", { className: "note-actions" },
                            editing
                              ? React.createElement(React.Fragment, null,
                                  React.createElement("button", { className: "icon-btn", type: "button", onClick: () => saveEditNote(note.id) }, "저장"),
                                  React.createElement("button", { className: "icon-btn", type: "button", onClick: cancelEditNote }, "취소")
                                )
                              : React.createElement("button", { className: "icon-btn", type: "button", onClick: () => startEditNote(note) }, "수정"),
                            React.createElement("button", { className: "icon-btn danger", type: "button", onClick: () => deleteNote(note.id) }, "삭제")
                          )
                        );
                      })
                  )
            )
          ),

          tab === TAB_SETTINGS && React.createElement("section", { className: "stack" },
            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "label" }, "참여자 관리"),
              React.createElement("div", { className: "settings-row" },
                React.createElement("div", { className: "inline", style: { gridTemplateColumns: "1fr 88px" } },
                  React.createElement("input", {
                    className: "field",
                    placeholder: "이름 추가",
                    value: newParticipant,
                    onChange: (e) => setNewParticipant(e.target.value),
                    onKeyDown: (e) => {
                      if (e.key === "Enter") {
                        e.preventDefault();
                        addParticipant();
                      }
                    }
                  }),
                  React.createElement("button", { className: "btn alt", onClick: addParticipant }, "추가")
                ),
                React.createElement("div", { className: "participant-list" },
                  state.participants.map((name) =>
                    React.createElement(ParticipantEditor, {
                      key: name,
                      name,
                      onRename: renameParticipant,
                      onDelete: deleteParticipant
                    })
                  )
                )
              )
            ),

            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "label" }, "환율 설정"),
              React.createElement("div", { className: "settings-row" },
                React.createElement("div", { className: "field", style: { fontWeight: 800, background: "#f8f4ee" } }, `1 엔 = ${Number(state.rate || 0).toFixed(4)} 원`),
                React.createElement("button", { className: "btn alt", onClick: fetchRate, disabled: busy }, busy ? "조회 중..." : "새로고침"),
                React.createElement("div", { className: "sync-state" }, state.rateUpdatedAt ? `적용 시각: ${state.rateUpdatedAt}` : "아직 API 갱신 전")
              )
            ),

            React.createElement("article", { className: "card" },
              React.createElement("div", { className: "label" }, "실시간 동기화"),
              React.createElement("div", { className: "settings-row" },
                React.createElement("button", { className: "btn alt", onClick: createOrCopySyncLink, disabled: busy }, "동기화 링크 생성/복사"),
                React.createElement("div", { className: "sync-state" }, syncLabel)
              )
            ),

            React.createElement("article", { className: "card" },
              React.createElement("button", { className: "btn danger", onClick: resetAll }, "전체 초기화")
            )
          )),

          React.createElement("nav", { className: "bottom-nav", "aria-label": "하단 탭" },
            React.createElement("div", { className: "bottom-nav-inner" },
              React.createElement("button", { className: `tab-btn ${tab === TAB_MAIN ? "active" : ""}`, onClick: () => setTab(TAB_MAIN) }, "메인"),
              React.createElement("button", { className: `tab-btn ${tab === TAB_HISTORY ? "active" : ""}`, onClick: () => setTab(TAB_HISTORY) }, "히스토리"),
              React.createElement("button", { className: `tab-btn ${tab === TAB_NOTES ? "active" : ""}`, onClick: () => setTab(TAB_NOTES) }, "메모"),
              React.createElement("button", { className: `tab-btn ${tab === TAB_SETTINGS ? "active" : ""}`, onClick: () => setTab(TAB_SETTINGS) }, "설정")
            )
          ),
          lastDeleted && React.createElement("div", { className: "undo-toast" },
            React.createElement("span", null, `'${lastDeleted.title}' 삭제됨`),
            React.createElement("button", { onClick: undoRemoveExpense }, "되돌리기")
          )
        )
      );
    }

    function ParticipantEditor({ name, onRename, onDelete }) {
      const [value, setValue] = useState(name);

      useEffect(() => {
        setValue(name);
      }, [name]);

      return (
        React.createElement("div", { className: "participant-row" },
          React.createElement("input", {
            className: "field",
            value,
            onChange: (e) => setValue(e.target.value),
            onBlur: () => onRename(name, value),
            onKeyDown: (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                onRename(name, value);
                e.currentTarget.blur();
              }
            }
          }),
          React.createElement("div", { className: "participant-actions" },
            React.createElement("button", { className: "icon-btn danger", onClick: () => onDelete(name) }, "삭제")
          )
        )
      );
    }

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("/service-worker.js").catch(() => {
          // no-op
        });
      });
    }

    createRoot(document.getElementById("root")).render(React.createElement(App));
  </script>
</body>
</html>
